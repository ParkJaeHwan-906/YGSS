pipeline {
  agent any

  environment {
    DOCKER_IMAGE  = 'ygss-backend'
    AI_IMAGE      = 'ygss-ai' 
    DOCKER_TAG    = "v${BUILD_NUMBER}"
    AI_TAG        = "v${BUILD_NUMBER}"
    K8S_NAMESPACE = 'ygss-prod'
    KUBECONFIG    = '/etc/rancher/k3s/k3s.yaml'

    MYSQL_PASSWORD = credentials('mysql-password')
    JWT_SECRET     = credentials('jwt-secret')
    GMS_SECRET_KEY = credentials('gms-secret-key')
    REDIS_PASSWORD = credentials('redis-password')
  }

  options {
    buildDiscarder(logRotator(numToKeepStr: '5'))
    timeout(time: 15, unit: 'MINUTES')
    timestamps()
    disableConcurrentBuilds()
  }

  stages {
    stage('ì²´í¬ì•„ì›ƒ & ë³€ê²½ ë¶„ì„') {
      steps {
        echo 'ì²´í¬ì•„ì›ƒ ë° ë³€ê²½ì‚¬í•­ ë¶„ì„'
        git branch: 'master',
            url: 'https://lab.ssafy.com/s13-bigdata-recom-sub1/S13P21A103.git',
            credentialsId: 'gitlab-git-token'

        script {
          env.GIT_COMMIT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
          
          // ë¹Œë“œ ë²ˆí˜¸ì™€ ì»¤ë°‹ì„ í•¨ê»˜ ì €ì¥í•˜ëŠ” ë°©ì‹
          def lastBuildInfo = sh(script: "cat /tmp/jenkins-last-build-info 2>/dev/null || echo 'FIRST_BUILD:0'", returnStdout: true).trim()
          def (prevCommit, prevBuildNum) = lastBuildInfo.split(':')
          def currentCommit = env.GIT_COMMIT
          def currentBuildNum = env.BUILD_NUMBER
          
          echo "ì´ì „ ë¹Œë“œ: ${prevCommit} (ë¹Œë“œ #${prevBuildNum})"
          echo "í˜„ì¬ ë¹Œë“œ: ${currentCommit} (ë¹Œë“œ #${currentBuildNum})"
          
          // ì§„ì§œ ë™ì¼í•œ ì»¤ë°‹ì¸ì§€ í™•ì¸ (ì—°ì†ëœ ë¹Œë“œ ë²ˆí˜¸ + ê°™ì€ ì»¤ë°‹)
          def isConsecutiveBuild = (currentBuildNum.toInteger() - prevBuildNum.toInteger()) == 1
          def isSameCommit = (prevCommit == currentCommit)
          
          if (isSameCommit && isConsecutiveBuild) {
            // ì§„ì§œ ë™ì¼í•œ ì»¤ë°‹ ì¬ë¹Œë“œ
            echo "ì—°ì†ëœ ë¹Œë“œì—ì„œ ë™ì¼í•œ ì»¤ë°‹ ê°ì§€ - ëª¨ë“  ë¹Œë“œ ìŠ¤í‚µ"
            env.BUILD_BACKEND = 'false'
            env.BUILD_AI = 'false'
            env.SKIP_REASON = 'SAME_COMMIT'
          } else if (prevCommit == 'FIRST_BUILD') {
            // ì²« ë¹Œë“œ
            echo "ì²« ë²ˆì§¸ ë¹Œë“œ - ì „ì²´ ë¹Œë“œ ì‹¤í–‰"
            env.BUILD_BACKEND = 'true'
            env.BUILD_AI = 'true'
            env.SKIP_REASON = 'FIRST_BUILD'
          } else {
            // ë‹¤ë¥¸ ì»¤ë°‹ì´ê±°ë‚˜ ë¹„ì—°ì† ë¹Œë“œ - ë³€ê²½ì‚¬í•­ ë¶„ì„
            echo "ì»¤ë°‹ ë³€ê²½ ê°ì§€ - ë³€ê²½ì‚¬í•­ ë¶„ì„ ì‹¤í–‰"
            
            def changedFiles = sh(
              script: "git diff --name-only ${prevCommit} ${currentCommit} || echo 'backend/ ai/'",
              returnStdout: true
            ).trim()

            echo "ë³€ê²½ëœ íŒŒì¼ë“¤:"
            echo "${changedFiles}"
            
            env.BUILD_BACKEND = changedFiles.contains('backend/') ? 'true' : 'false'
            env.BUILD_AI = changedFiles.contains('ai/') ? 'true' : 'false'
            env.SKIP_REASON = 'SELECTIVE'
            
            // ì•ˆì „ì¥ì¹˜
            if (env.BUILD_BACKEND == 'false' && env.BUILD_AI == 'false') {
              echo "ì£¼ìš” ë³€ê²½ì‚¬í•­ ê°ì§€ ì•ˆë¨, ì•ˆì „ì„ ìœ„í•´ ì „ì²´ ë¹Œë“œ"
              env.BUILD_BACKEND = 'true'
              env.BUILD_AI = 'true'
              env.SKIP_REASON = 'SAFETY_FALLBACK'
            }
          }

          echo """
ë¹Œë“œ ê³„íš:
â€¢ Backend ë¹Œë“œ: ${env.BUILD_BACKEND}
â€¢ AI ë¹Œë“œ: ${env.BUILD_AI}
â€¢ ìŠ¤í‚µ ì´ìœ : ${env.SKIP_REASON}
â€¢ ì—°ì† ë¹Œë“œ: ${isConsecutiveBuild}
          """
        }
      }
    }

    stage('íˆ´ ì„¤ì¹˜') {
      steps {
        sh '''
          if ! command -v kustomize &> /dev/null; then
            curl -Lo kustomize.tar.gz "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize/v5.7.1/kustomize_v5.7.1_linux_amd64.tar.gz"
            tar -xzf kustomize.tar.gz && sudo mv kustomize /usr/local/bin/ && rm -f kustomize.tar.gz
          fi
        '''
      }
    }

    stage('ë°±ì—”ë“œ ë¹Œë“œ') {
      when {
        environment name: 'BUILD_BACKEND', value: 'true'
      }
      steps {
        echo 'ë°±ì—”ë“œ ë¹Œë“œ ì‹œì‘'
        dir('backend') {
          sh '''
            chmod +x ./gradlew
            ./gradlew clean build -x test --no-daemon
            docker build -t $DOCKER_IMAGE:$DOCKER_TAG .
            docker tag $DOCKER_IMAGE:$DOCKER_TAG $DOCKER_IMAGE:latest
            echo "ë°±ì—”ë“œ ë¹Œë“œ ì™„ë£Œ: $DOCKER_TAG"
          '''
        }
      }
    }

    stage('ë°±ì—”ë“œ ìºì‹œ ì¬ì‚¬ìš©') {
      when {
        environment name: 'BUILD_BACKEND', value: 'false'
      }
      steps {
        script {
          echo 'ë°±ì—”ë“œ ë¹Œë“œ ìŠ¤í‚µ - ìºì‹œ ì¬ì‚¬ìš©'
          
          def latestExists = sh(
            script: "docker images -q $DOCKER_IMAGE:latest 2>/dev/null || true",
            returnStdout: true
          ).trim()
          
          if (latestExists) {
            sh "docker tag $DOCKER_IMAGE:latest $DOCKER_IMAGE:$DOCKER_TAG"
            echo "ê¸°ì¡´ ë°±ì—”ë“œ ì´ë¯¸ì§€ ì¬ì‚¬ìš©: latest â†’ $DOCKER_TAG"
          } else {
            echo "ê¸°ì¡´ latest ì´ë¯¸ì§€ ì—†ìŒ, ê°•ì œ ë¹Œë“œ ì „í™˜"
            env.BUILD_BACKEND = 'true'
            dir('backend') {
              sh '''
                chmod +x ./gradlew
                ./gradlew clean build -x test --no-daemon
                docker build -t $DOCKER_IMAGE:$DOCKER_TAG .
                docker tag $DOCKER_IMAGE:$DOCKER_TAG $DOCKER_IMAGE:latest
              '''
            }
          }
        }
      }
    }

    stage('AI ë¹Œë“œ') {
      when {
        environment name: 'BUILD_AI', value: 'true'
      }
      steps {
        echo 'AI ë¹Œë“œ ì‹œì‘'
        
        script {
          // AI Base ì´ë¯¸ì§€ í™•ì¸
          def baseExists = sh(
            script: 'docker images -q ygss-ai-base:latest 2>/dev/null || true',
            returnStdout: true
          ).trim()
          
          if (!baseExists) {
            echo 'AI Base ì´ë¯¸ì§€ ë¹Œë“œ í•„ìš”'
            dir('ai') {
              sh 'docker build -f Dockerfile.base -t ygss-ai-base:latest .'
            }
          }
        }

        dir('ai') {
          sh '''
            docker build -t $AI_IMAGE:$AI_TAG .
            docker tag $AI_IMAGE:$AI_TAG $AI_IMAGE:latest
            echo "AI ë¹Œë“œ ì™„ë£Œ: $AI_TAG"
          '''
        }
      }
    }

    stage('AI ìºì‹œ ì¬ì‚¬ìš©') {
      when {
        environment name: 'BUILD_AI', value: 'false'
      }
      steps {
        script {
          echo 'AI ë¹Œë“œ ìŠ¤í‚µ - ìºì‹œ ì¬ì‚¬ìš©'
          
          def latestExists = sh(
            script: "docker images -q $AI_IMAGE:latest 2>/dev/null || true", 
            returnStdout: true
          ).trim()
          
          if (latestExists) {
            sh "docker tag $AI_IMAGE:latest $AI_IMAGE:$AI_TAG"
            echo "ê¸°ì¡´ AI ì´ë¯¸ì§€ ì¬ì‚¬ìš©: latest â†’ $AI_TAG"
          } else {
            echo "ê¸°ì¡´ latest ì´ë¯¸ì§€ ì—†ìŒ, ê°•ì œ ë¹Œë“œ ì „í™˜"
            env.BUILD_AI = 'true'
            
            // Base ì´ë¯¸ì§€ í™•ì¸ í›„ ë¹Œë“œ
            def baseExists = sh(script: 'docker images -q ygss-ai-base:latest 2>/dev/null || true', returnStdout: true).trim()
            if (!baseExists) {
              dir('ai') {
                sh 'docker build -f Dockerfile.base -t ygss-ai-base:latest .'
              }
            }
            dir('ai') {
              sh '''
                docker build -t $AI_IMAGE:$AI_TAG .
                docker tag $AI_IMAGE:$AI_TAG $AI_IMAGE:latest
              '''
            }
          }
        }
      }
    }

    stage('ì´ë¯¸ì§€ Import') {
      steps {
        script {
          echo "ì´ë¯¸ì§€ Import ì‹œì‘"
          echo "â€¢ Backend ë¹Œë“œ ì—¬ë¶€: ${env.BUILD_BACKEND}"
          echo "â€¢ AI ë¹Œë“œ ì—¬ë¶€: ${env.BUILD_AI}"
          
          // Backend import
          if (env.BUILD_BACKEND == 'true') {
            sh '''
              echo "Backend ì´ë¯¸ì§€ k3s import"
              docker save "$DOCKER_IMAGE:$DOCKER_TAG" -o "/tmp/backend-$DOCKER_TAG.tar"
              sudo /usr/local/bin/k3s ctr images import "/tmp/backend-$DOCKER_TAG.tar"
              rm -f "/tmp/backend-$DOCKER_TAG.tar"
              echo "Backend ì´ë¯¸ì§€ import ì™„ë£Œ"
            '''
          } else {
            echo "Backend import ìŠ¤í‚µ"
          }
          
          // AI import
          if (env.BUILD_AI == 'true') {
            sh '''
              echo "AI ì´ë¯¸ì§€ k3s import"
              docker save "$AI_IMAGE:$AI_TAG" -o "/tmp/ai-$AI_TAG.tar"
              sudo /usr/local/bin/k3s ctr images import "/tmp/ai-$AI_TAG.tar"
              rm -f "/tmp/ai-$AI_TAG.tar"
              echo "AI ì´ë¯¸ì§€ import ì™„ë£Œ"
            '''
          } else {
            echo "AI import ìŠ¤í‚µ"
          }
          
          if (env.BUILD_BACKEND == 'false' && env.BUILD_AI == 'false') {
            echo "Importí•  ìƒˆ ì´ë¯¸ì§€ ì—†ìŒ (ëª¨ë‘ ìºì‹œ ì¬ì‚¬ìš©)"
          }
        }
      }
    }

    stage('K8s Secret ìƒì„±') {
      steps {
        sh '''
          kubectl create namespace $K8S_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n $K8S_NAMESPACE create secret generic backend-secrets \
            --from-literal=MYSQL_PASSWORD="$MYSQL_PASSWORD" \
            --from-literal=JWT_SECRET="$JWT_SECRET" \
            --from-literal=GMS_SECRET_KEY="$GMS_SECRET_KEY" \
            --from-literal=REDIS_PASSWORD="$REDIS_PASSWORD" \
            --dry-run=client -o yaml | kubectl apply -f -
        '''
      }
    }

    stage('ë°°í¬') {
      steps {
        sh '''
          cd k8s/overlays/prod
          
          # ì´ë¯¸ì§€ íƒœê·¸ ì„¤ì •
          kustomize edit set image ygss-backend:${DOCKER_TAG}
          kustomize edit set image ygss-ai:${AI_TAG}
          
          # ê²€ì¦ í›„ ë°°í¬
          kustomize build . | kubectl apply --dry-run=client -f -
          kubectl apply -k .
        '''
        
        script {
          echo "ë°°í¬ rollout ìƒíƒœ í™•ì¸"
          echo "â€¢ Backend rollout í•„ìš”: ${env.BUILD_BACKEND}"
          echo "â€¢ AI rollout í•„ìš”: ${env.BUILD_AI}"
          
          // ë¹Œë“œëœ ê²ƒë“¤ë§Œ rollout ëŒ€ê¸°
          if (env.BUILD_BACKEND == 'true') {
            echo "Backend ë°°í¬ ëŒ€ê¸° ì¤‘..."
            sh 'kubectl -n $K8S_NAMESPACE rollout status deployment/backend --timeout=300s'
          }
          if (env.BUILD_AI == 'true') {
            echo "AI ë°°í¬ ëŒ€ê¸° ì¤‘..."
            sh 'kubectl -n $K8S_NAMESPACE rollout status deployment/ai --timeout=300s'
          }
          
          if (env.BUILD_BACKEND == 'false' && env.BUILD_AI == 'false') {
            echo "Rollout ëŒ€ê¸° ì—†ìŒ (ì´ë¯¸ì§€ ë³€ê²½ ì—†ìŒ)"
          }
        }
      }
    }

    stage('í—¬ìŠ¤ì²´í¬') {
      steps {
        sleep(time: 10, unit: 'SECONDS')
        
        script {
          echo "í—¬ìŠ¤ì²´í¬ ì‹œì‘"
          echo "â€¢ Backend ì²´í¬ í•„ìš”: ${env.BUILD_BACKEND}"
          echo "â€¢ AI ì²´í¬ í•„ìš”: ${env.BUILD_AI}"
          
          // ë¹Œë“œëœ ê²ƒë“¤ë§Œ í—¬ìŠ¤ì²´í¬
          if (env.BUILD_BACKEND == 'true') {
            echo 'ë°±ì—”ë“œ í—¬ìŠ¤ì²´í¬'
            timeout(time: 2, unit: 'MINUTES') {
              waitUntil {
                def code = sh(script: 'curl -s -o /dev/null -w "%{http_code}" https://j13a103.p.ssafy.io/api/infra || echo 000', returnStdout: true).trim()
                echo "ë°±ì—”ë“œ ì‘ë‹µ: ${code}"
                return (code == '200')
              }
            }
          }
          
          if (env.BUILD_AI == 'true') {
            echo 'AI í—¬ìŠ¤ì²´í¬'
            timeout(time: 2, unit: 'MINUTES') {
              waitUntil {
                def code = sh(script: 'curl -s -o /dev/null -w "%{http_code}" https://j13a103.p.ssafy.io/ai/health/ || echo 000', returnStdout: true).trim()
                echo "AI ì‘ë‹µ: ${code}"
                return (code == '200')
              }
            }
          }
          
          if (env.BUILD_BACKEND == 'false' && env.BUILD_AI == 'false') {
            echo "í—¬ìŠ¤ì²´í¬ ìŠ¤í‚µ (ìƒˆ ë°°í¬ ì—†ìŒ)"
          }
        }
      }
    }

    stage('ì •ë¦¬') {
      steps {
        sh '''
          # íŠ¹ì • ì´ë¯¸ì§€ë§Œ ì•ˆì „í•˜ê²Œ ì •ë¦¬ (ìµœê·¼ 3ê°œ ë²„ì „ ìœ ì§€)
          for image in ygss-backend ygss-ai; do
            OLD_TAGS=$(docker images $image --format '{{.Tag}}' | grep -E '^v[0-9]+' | sort -V -r | tail -n +4)
            for tag in $OLD_TAGS; do
              docker rmi "$image:$tag" 2>/dev/null || true
            done
          done
          
          # ëŒ•ê¸€ë§ ì´ë¯¸ì§€ë§Œ ì •ë¦¬
          docker image prune -f
        '''
      }
    }
  }

  post {
    success {
      // ë¹Œë“œ ì„±ê³µ ì‹œì—ë§Œ í˜„ì¬ ë¹Œë“œ ì •ë³´ ì €ì¥
      script {
        sh "echo '${env.GIT_COMMIT}:${env.BUILD_NUMBER}' > /tmp/jenkins-last-build-info"
      }
      
      echo """
ìŠ¤ë§ˆíŠ¸ ë°°í¬ ì™„ë£Œ!

ğŸ“‹ ìš”ì•½:
â€¢ ì»¤ë°‹: ${env.GIT_COMMIT}
â€¢ Backend ë¹Œë“œ: ${env.BUILD_BACKEND}
â€¢ AI ë¹Œë“œ: ${env.BUILD_AI}
â€¢ ìŠ¤í‚µ ì´ìœ : ${env.SKIP_REASON}

ğŸ”— ì—”ë“œí¬ì¸íŠ¸:
â€¢ Backend: https://j13a103.p.ssafy.io/api/infra
â€¢ AI: https://j13a103.p.ssafy.io/ai/health/
      """
    }
    failure {
      echo 'ë°°í¬ ì‹¤íŒ¨!'
      sh '''
        kubectl -n $K8S_NAMESPACE get pods -o wide || true
        kubectl -n $K8S_NAMESPACE logs -l app=backend --tail=20 || true
        kubectl -n $K8S_NAMESPACE logs -l app=ai --tail=20 || true
      '''
      // ì‹¤íŒ¨ ì‹œì—ëŠ” ë¹Œë“œ ì •ë³´ë¥¼ ì €ì¥í•˜ì§€ ì•ŠìŒ (ë‹¤ìŒ ë¹Œë“œì—ì„œ ì¬ì‹œë„)
    }
    always {
      cleanWs()
    }
  }
}