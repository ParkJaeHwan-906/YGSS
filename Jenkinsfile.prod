pipeline {
  agent any

  environment {
    DOCKER_IMAGE  = 'ygss-backend'
    AI_IMAGE      = 'ygss-ai' 
    DOCKER_TAG    = "v${BUILD_NUMBER}"
    AI_TAG        = "v${BUILD_NUMBER}"
    K8S_NAMESPACE = 'ygss-prod'
    KUBECONFIG    = '/etc/rancher/k3s/k3s.yaml'

    MYSQL_PASSWORD = credentials('mysql-password')
    JWT_SECRET     = credentials('jwt-secret')
    GMS_SECRET_KEY = credentials('gms-secret-key')
    REDIS_PASSWORD = credentials('redis-password')
  }

  options {
    buildDiscarder(logRotator(numToKeepStr: '5'))
    timeout(time: 15, unit: 'MINUTES')
    timestamps()
    disableConcurrentBuilds()
  }

  stages {
    stage('체크아웃 & 변경 분석') {
      steps {
        echo '체크아웃 및 변경사항 분석'
        git branch: 'master',
            url: 'https://lab.ssafy.com/s13-bigdata-recom-sub1/S13P21A103.git',
            credentialsId: 'gitlab-git-token'

        script {
          env.GIT_COMMIT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
          
          // 빌드 번호와 커밋을 함께 저장하는 방식
          def lastBuildInfo = sh(script: "cat /tmp/jenkins-last-build-info 2>/dev/null || echo 'FIRST_BUILD:0'", returnStdout: true).trim()
          def (prevCommit, prevBuildNum) = lastBuildInfo.split(':')
          def currentCommit = env.GIT_COMMIT
          def currentBuildNum = env.BUILD_NUMBER
          
          echo "이전 빌드: ${prevCommit} (빌드 #${prevBuildNum})"
          echo "현재 빌드: ${currentCommit} (빌드 #${currentBuildNum})"
          
          // 진짜 동일한 커밋인지 확인 (연속된 빌드 번호 + 같은 커밋)
          def isConsecutiveBuild = (currentBuildNum.toInteger() - prevBuildNum.toInteger()) == 1
          def isSameCommit = (prevCommit == currentCommit)
          
          if (isSameCommit && isConsecutiveBuild) {
            // 진짜 동일한 커밋 재빌드
            echo "연속된 빌드에서 동일한 커밋 감지 - 모든 빌드 스킵"
            env.BUILD_BACKEND = 'false'
            env.BUILD_AI = 'false'
            env.SKIP_REASON = 'SAME_COMMIT'
          } else if (prevCommit == 'FIRST_BUILD') {
            // 첫 빌드
            echo "첫 번째 빌드 - 전체 빌드 실행"
            env.BUILD_BACKEND = 'true'
            env.BUILD_AI = 'true'
            env.SKIP_REASON = 'FIRST_BUILD'
          } else {
            // 다른 커밋이거나 비연속 빌드 - 변경사항 분석
            echo "커밋 변경 감지 - 변경사항 분석 실행"
            
            def changedFiles = sh(
              script: "git diff --name-only ${prevCommit} ${currentCommit} || echo 'backend/ ai/'",
              returnStdout: true
            ).trim()

            echo "변경된 파일들:"
            echo "${changedFiles}"
            
            env.BUILD_BACKEND = changedFiles.contains('backend/') ? 'true' : 'false'
            env.BUILD_AI = changedFiles.contains('ai/') ? 'true' : 'false'
            env.SKIP_REASON = 'SELECTIVE'
            
            // 안전장치
            if (env.BUILD_BACKEND == 'false' && env.BUILD_AI == 'false') {
              echo "주요 변경사항 감지 안됨, 안전을 위해 전체 빌드"
              env.BUILD_BACKEND = 'true'
              env.BUILD_AI = 'true'
              env.SKIP_REASON = 'SAFETY_FALLBACK'
            }
          }

          echo """
빌드 계획:
• Backend 빌드: ${env.BUILD_BACKEND}
• AI 빌드: ${env.BUILD_AI}
• 스킵 이유: ${env.SKIP_REASON}
• 연속 빌드: ${isConsecutiveBuild}
          """
        }
      }
    }

    stage('툴 설치') {
      steps {
        sh '''
          if ! command -v kustomize &> /dev/null; then
            curl -Lo kustomize.tar.gz "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize/v5.7.1/kustomize_v5.7.1_linux_amd64.tar.gz"
            tar -xzf kustomize.tar.gz && sudo mv kustomize /usr/local/bin/ && rm -f kustomize.tar.gz
          fi
        '''
      }
    }

    stage('백엔드 빌드') {
      when {
        environment name: 'BUILD_BACKEND', value: 'true'
      }
      steps {
        echo '백엔드 빌드 시작'
        dir('backend') {
          sh '''
            chmod +x ./gradlew
            ./gradlew clean build -x test --no-daemon
            docker build -t $DOCKER_IMAGE:$DOCKER_TAG .
            docker tag $DOCKER_IMAGE:$DOCKER_TAG $DOCKER_IMAGE:latest
            echo "백엔드 빌드 완료: $DOCKER_TAG"
          '''
        }
      }
    }

    stage('백엔드 캐시 재사용') {
      when {
        environment name: 'BUILD_BACKEND', value: 'false'
      }
      steps {
        script {
          echo '백엔드 빌드 스킵 - 캐시 재사용'
          
          def latestExists = sh(
            script: "docker images -q $DOCKER_IMAGE:latest 2>/dev/null || true",
            returnStdout: true
          ).trim()
          
          if (latestExists) {
            sh "docker tag $DOCKER_IMAGE:latest $DOCKER_IMAGE:$DOCKER_TAG"
            echo "기존 백엔드 이미지 재사용: latest → $DOCKER_TAG"
          } else {
            echo "기존 latest 이미지 없음, 강제 빌드 전환"
            env.BUILD_BACKEND = 'true'
            dir('backend') {
              sh '''
                chmod +x ./gradlew
                ./gradlew clean build -x test --no-daemon
                docker build -t $DOCKER_IMAGE:$DOCKER_TAG .
                docker tag $DOCKER_IMAGE:$DOCKER_TAG $DOCKER_IMAGE:latest
              '''
            }
          }
        }
      }
    }

    stage('AI 빌드') {
      when {
        environment name: 'BUILD_AI', value: 'true'
      }
      steps {
        echo 'AI 빌드 시작'
        
        script {
          // AI Base 이미지 확인
          def baseExists = sh(
            script: 'docker images -q ygss-ai-base:latest 2>/dev/null || true',
            returnStdout: true
          ).trim()
          
          if (!baseExists) {
            echo 'AI Base 이미지 빌드 필요'
            dir('ai') {
              sh 'docker build -f Dockerfile.base -t ygss-ai-base:latest .'
            }
          }
        }

        dir('ai') {
          sh '''
            docker build -t $AI_IMAGE:$AI_TAG .
            docker tag $AI_IMAGE:$AI_TAG $AI_IMAGE:latest
            echo "AI 빌드 완료: $AI_TAG"
          '''
        }
      }
    }

    stage('AI 캐시 재사용') {
      when {
        environment name: 'BUILD_AI', value: 'false'
      }
      steps {
        script {
          echo 'AI 빌드 스킵 - 캐시 재사용'
          
          def latestExists = sh(
            script: "docker images -q $AI_IMAGE:latest 2>/dev/null || true", 
            returnStdout: true
          ).trim()
          
          if (latestExists) {
            sh "docker tag $AI_IMAGE:latest $AI_IMAGE:$AI_TAG"
            echo "기존 AI 이미지 재사용: latest → $AI_TAG"
          } else {
            echo "기존 latest 이미지 없음, 강제 빌드 전환"
            env.BUILD_AI = 'true'
            
            // Base 이미지 확인 후 빌드
            def baseExists = sh(script: 'docker images -q ygss-ai-base:latest 2>/dev/null || true', returnStdout: true).trim()
            if (!baseExists) {
              dir('ai') {
                sh 'docker build -f Dockerfile.base -t ygss-ai-base:latest .'
              }
            }
            dir('ai') {
              sh '''
                docker build -t $AI_IMAGE:$AI_TAG .
                docker tag $AI_IMAGE:$AI_TAG $AI_IMAGE:latest
              '''
            }
          }
        }
      }
    }

    stage('이미지 Import') {
      steps {
        script {
          echo "이미지 Import 시작"
          echo "• Backend 빌드 여부: ${env.BUILD_BACKEND}"
          echo "• AI 빌드 여부: ${env.BUILD_AI}"
          
          // Backend import
          if (env.BUILD_BACKEND == 'true') {
            sh '''
              echo "Backend 이미지 k3s import"
              docker save "$DOCKER_IMAGE:$DOCKER_TAG" -o "/tmp/backend-$DOCKER_TAG.tar"
              sudo /usr/local/bin/k3s ctr images import "/tmp/backend-$DOCKER_TAG.tar"
              rm -f "/tmp/backend-$DOCKER_TAG.tar"
              echo "Backend 이미지 import 완료"
            '''
          } else {
            echo "Backend import 스킵"
          }
          
          // AI import
          if (env.BUILD_AI == 'true') {
            sh '''
              echo "AI 이미지 k3s import"
              docker save "$AI_IMAGE:$AI_TAG" -o "/tmp/ai-$AI_TAG.tar"
              sudo /usr/local/bin/k3s ctr images import "/tmp/ai-$AI_TAG.tar"
              rm -f "/tmp/ai-$AI_TAG.tar"
              echo "AI 이미지 import 완료"
            '''
          } else {
            echo "AI import 스킵"
          }
          
          if (env.BUILD_BACKEND == 'false' && env.BUILD_AI == 'false') {
            echo "Import할 새 이미지 없음 (모두 캐시 재사용)"
          }
        }
      }
    }

    stage('K8s Secret 생성') {
      steps {
        sh '''
          kubectl create namespace $K8S_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n $K8S_NAMESPACE create secret generic backend-secrets \
            --from-literal=MYSQL_PASSWORD="$MYSQL_PASSWORD" \
            --from-literal=JWT_SECRET="$JWT_SECRET" \
            --from-literal=GMS_SECRET_KEY="$GMS_SECRET_KEY" \
            --from-literal=REDIS_PASSWORD="$REDIS_PASSWORD" \
            --dry-run=client -o yaml | kubectl apply -f -
        '''
      }
    }

    stage('배포') {
      steps {
        sh '''
          cd k8s/overlays/prod
          
          # 이미지 태그 설정
          kustomize edit set image ygss-backend:${DOCKER_TAG}
          kustomize edit set image ygss-ai:${AI_TAG}
          
          # 검증 후 배포
          kustomize build . | kubectl apply --dry-run=client -f -
          kubectl apply -k .
        '''
        
        script {
          echo "배포 rollout 상태 확인"
          echo "• Backend rollout 필요: ${env.BUILD_BACKEND}"
          echo "• AI rollout 필요: ${env.BUILD_AI}"
          
          // 빌드된 것들만 rollout 대기
          if (env.BUILD_BACKEND == 'true') {
            echo "Backend 배포 대기 중..."
            sh 'kubectl -n $K8S_NAMESPACE rollout status deployment/backend --timeout=300s'
          }
          if (env.BUILD_AI == 'true') {
            echo "AI 배포 대기 중..."
            sh 'kubectl -n $K8S_NAMESPACE rollout status deployment/ai --timeout=300s'
          }
          
          if (env.BUILD_BACKEND == 'false' && env.BUILD_AI == 'false') {
            echo "Rollout 대기 없음 (이미지 변경 없음)"
          }
        }
      }
    }

    stage('헬스체크') {
      steps {
        sleep(time: 10, unit: 'SECONDS')
        
        script {
          echo "헬스체크 시작"
          echo "• Backend 체크 필요: ${env.BUILD_BACKEND}"
          echo "• AI 체크 필요: ${env.BUILD_AI}"
          
          // 빌드된 것들만 헬스체크
          if (env.BUILD_BACKEND == 'true') {
            echo '백엔드 헬스체크'
            timeout(time: 2, unit: 'MINUTES') {
              waitUntil {
                def code = sh(script: 'curl -s -o /dev/null -w "%{http_code}" https://j13a103.p.ssafy.io/api/infra || echo 000', returnStdout: true).trim()
                echo "백엔드 응답: ${code}"
                return (code == '200')
              }
            }
          }
          
          if (env.BUILD_AI == 'true') {
            echo 'AI 헬스체크'
            timeout(time: 2, unit: 'MINUTES') {
              waitUntil {
                def code = sh(script: 'curl -s -o /dev/null -w "%{http_code}" https://j13a103.p.ssafy.io/ai/health/ || echo 000', returnStdout: true).trim()
                echo "AI 응답: ${code}"
                return (code == '200')
              }
            }
          }
          
          if (env.BUILD_BACKEND == 'false' && env.BUILD_AI == 'false') {
            echo "헬스체크 스킵 (새 배포 없음)"
          }
        }
      }
    }

    stage('정리') {
      steps {
        sh '''
          # 특정 이미지만 안전하게 정리 (최근 3개 버전 유지)
          for image in ygss-backend ygss-ai; do
            OLD_TAGS=$(docker images $image --format '{{.Tag}}' | grep -E '^v[0-9]+' | sort -V -r | tail -n +4)
            for tag in $OLD_TAGS; do
              docker rmi "$image:$tag" 2>/dev/null || true
            done
          done
          
          # 댕글링 이미지만 정리
          docker image prune -f
        '''
      }
    }
  }

  post {
    success {
      // 빌드 성공 시에만 현재 빌드 정보 저장
      script {
        sh "echo '${env.GIT_COMMIT}:${env.BUILD_NUMBER}' > /tmp/jenkins-last-build-info"
      }
      
      echo """
스마트 배포 완료!

📋 요약:
• 커밋: ${env.GIT_COMMIT}
• Backend 빌드: ${env.BUILD_BACKEND}
• AI 빌드: ${env.BUILD_AI}
• 스킵 이유: ${env.SKIP_REASON}

🔗 엔드포인트:
• Backend: https://j13a103.p.ssafy.io/api/infra
• AI: https://j13a103.p.ssafy.io/ai/health/
      """
    }
    failure {
      echo '배포 실패!'
      sh '''
        kubectl -n $K8S_NAMESPACE get pods -o wide || true
        kubectl -n $K8S_NAMESPACE logs -l app=backend --tail=20 || true
        kubectl -n $K8S_NAMESPACE logs -l app=ai --tail=20 || true
      '''
      // 실패 시에는 빌드 정보를 저장하지 않음 (다음 빌드에서 재시도)
    }
    always {
      cleanWs()
    }
  }
}